/* eslint-env browser */

/* global Webex */

/* eslint-disable camelcase */
/* eslint-disable max-nested-callbacks */
/* eslint-disable no-alert */
/* eslint-disable no-console */
/* eslint-disable require-jsdoc */
/* eslint-disable arrow-body-style */
/* eslint-disable max-len */


// This is one way you might programattically determine your redirect_uri
// depending on where you've deployed your app, but you're probably better off
// having development/staging/production builds and injecting directly from the
// environment.
let redirect_uri = `${window.location.protocol}//${window.location.host}`;

if (window.location.pathname) {
  redirect_uri += window.location.pathname;
}

let activeMeeting, remoteShareStream;
let isPaste;
let isOAuth;

// eslint-disable-next-line no-multi-assign
let webex = window.webex = Webex.init({
  config: {
    logger: {
      level: 'debug'
    },
    meetings: {
      reconnection: {
        enabled: true
      }
    },
    // Any other sdk config we need
    credentials: {
      client_id: 'C078542199e086020446378c346024881cc4ec5e475552d9cc9a93614d5bacf1e',
      redirect_uri,
      scope: 'spark:all spark:kms'
    }
  }
});

// There's a few different events that'll let us know that we need to start listening
// for incoming calls, so we'll wrap a few things up in a function.
function connect() {
  return new Promise((resolve) => {
    // Listen for added meetings
    webex.meetings.on('meeting:added', (addedMeetingEvent) => {
      if (addedMeetingEvent.type === 'INCOMING') {
        const addedMeeting = addedMeetingEvent.meeting;

        // Acknowledge to the server that we received the call on our device
        addedMeeting.acknowledge(addedMeetingEvent.type)
          .then(() => {
            if (confirm('Answer incoming call')) {
              joinMeeting(addedMeeting);
            }
            else {
              addedMeeting.decline();
            }
          });
      }
    });

    // Register our device with Webex cloud
    if (!webex.meetings.registered) {
      webex.meetings.register()
        // Sync our meetings with existing meetings on the server
        .then(() => webex.meetings.syncMeetings())
        .then(() => {
          // This is just a little helper for our selenium tests and doesn't
          // really matter for the example
          document.body.classList.add('listening');
          if (isPaste) {
            document.getElementById('register-status').innerText = 'registered';
          }

          // Our device is now connected and ready to call
          resolve();
        })
        // This is a terrible way to handle errors, but anything more specific is
        // going to depend a lot on your app
        .catch((err) => {
          console.log('error in connection');
          console.error(err);
          // we'll rethrow here since we didn't really *handle* the error, we just
          // reported it
          throw err;
        });
    }
    else {
      // Device was already connected
      resolve();
    }
  });
}

// Similarly, there are a few different ways we'll get a meeting Object, so let's
// put meeting handling inside its own function.
function bindMeetingEvents(meeting) {
  // meeting is a meeting instance, not a promise, so to know if things break,
  // we'll need to listen for the error event. Again, this is a rather naive
  // handler.
  meeting.on('error', (err) => {
    console.error(err);
  });

  meeting.on('meeting:startedSharingRemote', () => {
    // Set the source of the video element to the previously stored stream
    document.getElementById('remote-screen').srcObject = remoteShareStream;
    document.getElementById('screenshare-tracks-remote').innerText = 'SHARING';
  });

  meeting.on('meeting:stoppedSharingRemote', () => {
    document.getElementById('remote-screen').srcObject = null;
    document.getElementById('screenshare-tracks-remote').innerText = 'STOPPED';
  });

  // Handle media streams changes to ready state
  meeting.on('media:ready', (media) => {
    if (!media) {
      return;
    }
    console.log(`MEDIA:READY type:${media.type}`);
    if (media.type === 'local') {
      document.getElementById('self-view').srcObject = media.stream;
    }
    if (media.type === 'remoteVideo') {
      document.getElementById('remote-view-video').srcObject = media.stream;
    }
    if (media.type === 'remoteAudio') {
      document.getElementById('remote-view-audio').srcObject = media.stream;
    }
    if (media.type === 'remoteShare') {
      // Remote share streams become active immediately on join, even if nothing is being shared
      remoteShareStream = media.stream;
    }
    if (media.type === 'localShare') {
      document.getElementById('self-screen').srcObject = media.stream;
    }
  });

  // Handle media streams stopping
  meeting.on('media:stopped', (media) => {
    // Remove media streams
    if (media.type === 'local') {
      document.getElementById('self-view').srcObject = null;
    }
    if (media.type === 'remoteVideo') {
      document.getElementById('remote-view-video').srcObject = null;
    }
    if (media.type === 'remoteAudio') {
      document.getElementById('remote-view-audio').srcObject = null;
    }
    if (media.type === 'localShare') {
      document.getElementById('self-screen').srcObject = null;
    }
  });

  // Handle share specific events
  meeting.on('meeting:startedSharingLocal', () => {
    document.getElementById('screenshare-tracks').innerText = 'SHARING';
  });
  meeting.on('meeting:stoppedSharingLocal', () => {
    document.getElementById('screenshare-tracks').innerText = 'STOPPED';
  });

  // Update participant info
  meeting.members.on('members:update', (delta) => {
    const {full: membersData} = delta;
    const memberIDs = Object.keys(membersData);

    memberIDs.forEach((memberID) => {
      const memberObject = membersData[memberID];

      // Devices are listed in the memberships object.
      // We are not concerned with them in this demo
      if (memberObject.isUser) {
        if (memberObject.isSelf) {
          document.getElementById('call-status-local').innerText = memberObject.status;
        }
        else {
          document.getElementById('call-status-remote').innerText = memberObject.status;
        }
      }
    });
  });

  // Of course, we'd also like to be able to end the meeting:
  const leaveMeeting = () => meeting.leave();

  document.getElementById('hangup').addEventListener('click', leaveMeeting, {once: true});

  meeting.on('all', (event) => {
    console.log(event);
  });
}


// Waits for the meeting to be media update ready
function waitForMediaReady(meeting) {
  return new Promise((resolve, reject) => {
    if (meeting.canUpdateMedia()) {
      resolve();
    }
    else {
      console.info('SHARE-SCREEN: Unable to update media, pausing to retry...');
      let retryAttempts = 0;

      const retryInterval = setInterval(() => {
        retryAttempts += 1;
        console.info('SHARE-SCREEN: Retry update media check');

        if (meeting.canUpdateMedia()) {
          console.info('SHARE-SCREEN: Able to update media, continuing');
          clearInterval(retryInterval);
          resolve();
        }
        // If we can't update our media after 15 seconds, something went wrong
        else if (retryAttempts > 15) {
          console.error('SHARE-SCREEN: Unable to share screen, media was not able to update.');
          clearInterval(retryInterval);
          reject();
        }
      }, 1000);
    }
  });
}

// Join the meeting and add media
function joinMeeting(meeting) {
  // Save meeting to global object
  activeMeeting = meeting;

  // Call our helper function for binding events to meetings
  bindMeetingEvents(meeting);

  return meeting.join().then(() => {
    const mediaSettings = {
      receiveVideo: true,
      receiveAudio: true,
      receiveShare: true,
      sendVideo: true,
      sendAudio: true,
      sendShare: false
    };

    return meeting.getMediaStreams(mediaSettings).then((mediaStreams) => {
      const [localStream, localShare] = mediaStreams;

      meeting.addMedia({
        localShare,
        localStream,
        mediaSettings
      });
    });
  });
}

function handleRadio() {
  // checks which radio is enabled
  isPaste = document.getElementById('paste').checked;
  isOAuth = document.getElementById('oauth').checked;

  const div = document.createElement('div');

  // removes the child node of the form if anything exists
  while (document.getElementById('authForm').firstChild) {
    document.getElementById('authForm').removeChild(document.getElementById('authForm').firstChild);
  }

  // adds the correct form based on enabled radio
  if (isOAuth) {
    const legend = document.createElement('legend');
    const login = document.createElement('input');
    const logout = document.createElement('input');
    const loginStatus = document.createElement('p');


    legend.innerText = 'Authentication with OAuth';
    loginStatus.innerText = 'not logged in';

    login.setAttribute('id', 'login');
    login.setAttribute('title', 'login');
    login.setAttribute('type', 'submit');
    login.setAttribute('value', 'login');
    logout.setAttribute('id', 'logout');
    logout.setAttribute('title', 'logout');
    logout.setAttribute('type', 'submit');
    logout.setAttribute('value', 'logout');
    logout.setAttribute('disabled', 'disabled');
    loginStatus.setAttribute('id', 'login-status');
    div.append(legend);
    div.append(login);
    div.append(logout);
    div.append(loginStatus);

    // div.innerHTML = `
    //     <legend>Authentication with OAuth </legend>
    //           <input id="login" title="login" type="submit" value="login">
    //           <input id="logout" title="logout" type="submit" value="logout" disabled="disabled">
    //           <p id="login-status">not logged in</p>
    // `;

    document.getElementById('authForm').appendChild(div);

    // Now, let's set up oauth login
    document.getElementById('credentials').addEventListener('submit', (event) => {
    // let's make sure we don't reload the page when we submit the form
      event.preventDefault();

      // Initiate login to Webex account
      webex.authorization.initiateLogin();
    });

    // Now, let's set up logout
    document.getElementById('logout').addEventListener('click', (event) => {
      // let's make sure we don't reload the page when we submit the form
      event.preventDefault();

      if (webex.canAuthorize) {
        // if already authenticated, logout on click
        webex.logout();
      }
    });
  }

  if (isPaste) {
    const legend = document.createElement('legend');
    const accessToken = document.createElement('input');
    const webexInit = document.createElement('input');
    const register = document.createElement('input');
    const registerStatus = document.createElement('p');

    legend.innerText = 'Authentication with Access Token';
    registerStatus.innerText = 'not registered';
    accessToken.setAttribute('id', 'access-token');
    accessToken.setAttribute('name', 'accessToken');
    accessToken.setAttribute('placeholder', 'Your access token');
    accessToken.setAttribute('type', 'Text');
    webexInit.setAttribute('id', 'webexInit');
    webexInit.setAttribute('title', 'webex.init()');
    webexInit.setAttribute('type', 'submit');
    webexInit.setAttribute('value', 'webex.init()');
    register.setAttribute('id', 'register');
    register.setAttribute('title', 'register');
    register.setAttribute('type', 'submit');
    register.setAttribute('value', 'register');
    registerStatus.setAttribute('id', 'register-status');
    div.append(legend);
    div.append(accessToken);
    div.append(webexInit);
    div.append(register);
    div.append(registerStatus);


    document.getElementById('authForm').appendChild(div);

    // Let's wire our form fields up to localStorage so we don't have to
    // retype things everytime we reload the page.
    [
      'access-token'
    ].forEach((id) => {
      const el = document.getElementById(id);

      el.value = localStorage.getItem(id);
      el.addEventListener('change', (event) => {
        localStorage.setItem(id, event.target.value);
      });
    });

    // add event handlers for webex.init() button
    document.getElementById('webexInit').addEventListener('click', (event) => {
      // let's make sure we don't reload the page when we want to initialize webex
      event.preventDefault();

      webex = window.webex = Webex.init({
        config: {
          logger: {
            level: 'debug'
          },
          meetings: {
            reconnection: {
              enabled: true
            }
          }
          // Any other sdk config we need
        },

        credentials: {
          access_token: document.getElementById('access-token').value
        }
      });
    });

    // hook up our event handler for register button
    document.getElementById('register').addEventListener('click', () => {
      // again, we don't want to reload when we try to register
      event.preventDefault();

      connect().then(() => enabledButton());
    });
  }
}

// Enabled buttons after registering or completing the oauth flow
function enabledButton() {
  if (webex.canAuthorize) {
    document.getElementById('dial').disabled = false;
    document.getElementById('invitee').disabled = false;
    document.getElementById('hangup').disabled = false;
    document.getElementById('share-screen').disabled = false;
    document.getElementById('stop-screen-share').disabled = false;
    document.getElementById('logout').disabled = false;
    document.getElementById('login').disabled = true;
  }
}

// checks which radio is enabled and what to display back to the user
handleRadio();

// adding event handler for share-screen button
document.getElementById('share-screen').addEventListener('click', () => {
  if (activeMeeting) {
  // First check if we can update
    waitForMediaReady(activeMeeting).then(() => {
      console.info('SHARE-SCREEN: Sharing screen via `shareScreen()`');
      activeMeeting.shareScreen()
        .then(() => {
          console.info('SHARE-SCREEN: Screen successfully added to meeting.');
        })
        .catch((e) => {
          console.error('SHARE-SCREEN: Unable to share screen, error:');
          console.error(e);
        });
    });
  }
  else {
    console.error('No active meeting available to share screen.');
  }
});

// adding event handler for stop-screen-share button
document.getElementById('stop-screen-share').addEventListener('click', () => {
  if (activeMeeting) {
  // First check if we can update, if not, wait and retry
    waitForMediaReady(activeMeeting).then(() => {
      activeMeeting.stopShare();
    });
  }
});

// adding event handler for dialer button
document.getElementById('dialer').addEventListener('submit', (event) => {
// again, we don't want to reload when we try to dial
  event.preventDefault();

  const destination = document.getElementById('invitee').value;

  // we'll use `connect()` (even though we might already be connected or
  // connecting) to make sure we've got a functional webex instance.
  connect()
    .then(() => {
    // Create the meeting
      return webex.meetings.create(destination).then((meeting) => {
      // Pass the meeting to our join meeting helper
        return joinMeeting(meeting);
      });
    })
    .catch((error) => {
      console.log('error in dialer handler');
      // Report the error
      console.error(error);

    // Implement error handling here
    });
});


// after webex initialized, enabled the other buttons
webex.once('ready', () => {
  enabledButton();
  if (webex.canAuthorize) {
    document.getElementById('login-status').innerText = 'login completed';
  }
});
